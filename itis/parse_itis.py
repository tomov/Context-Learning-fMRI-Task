# assumes outputs generated by gen_itis.sh using optseq2 
# (in folder par, etc)
# parses them and generates csv files for psychopy
# note that gen_itis.sh only generates train trial ITIs
# also note that this is for the fMRI task only
#

import os
import sys
import csv
from numpy.random import shuffle, seed
import numpy as np

roles = ['irrelevant', 'modulatory', 'additive']

stimuli = [
        {
            'restaurants': ["Molina's Cantina", "Restaurante Arroyo", "El Coyote Cafe"],
            'foods':       ["mexican_food0.png", "mexican_food1.png", "mexican_food2.png"]
        },
        {
            'restaurants': ["Le Parisien", "Chez Toinette", "Au Petit Sud Ouest"],
            'foods':       ["french_food0.png", "french_food1.png", "french_food2.png"]
        },
        {
            'restaurants': ["Lau's Dim Sum Bar", "Shanghai Dumpling King", "Happy Lamb Hot Pot"],
            'foods':       ["chinese_food0.png", "chinese_food1.png", "chinese_food2.png"]
        },
        {
            'restaurants': ["Breakfast at Tiffany's", "Sweet Maple", "Mission Beach Cafe"],
            'foods':       ["brunch_food0.png", "brunch_food1.png", "brunch_food2.png"]
        },
        {
            'restaurants': ["Myconos Restaurant", "Mediterranean Grill", "Gyro King"],
            'foods':       ["greek_food0.png", "greek_food1.png", "greek_food2.png"]
        },
        {
            'restaurants': ["Izakaya Sozai", "Onigilly Express", "Sanraku Restaurant"],
            'foods':       ["japanese_food0.png", "japanese_food1.png", "japanese_food2.png"]
        },
        {
            'restaurants': ["Little Delhi House", "Curry Leaf Restaurant", "Tandoori Kitchen"],
            'foods':       ["indian_food0.png", "indian_food1.png", "indian_food2.png"]
        },
        {
            'restaurants': ["Restorante Milano", "Trattoria Contadina", "Fino Bar & Restorante"],
            'foods':       ["italian_food0.png", "italian_food1.png", "italian_food2.png"]
        },
        {
            'restaurants': ["Dave's Sandwiches", "Burger Masters", "Metro Drive-In"],
            'foods':       ["fast_food0.png", "fast_food1.png", "fast_food2.png"]
        }
]

practice_stimuli = [
        {
            'restaurants': ['Seven Hills', 'Blue Bottle Cafe', 'Restaurant Gary Danko'],
            'foods':       ["practice_food0.png", "practice_food1.png", "practice_food2.png"]
        }
] * len(stimuli)


# this is for the fMRI mode only
#
def get_correct_button(isSick):
    if isSick:
        return '1' # sick = index finger
    else:
        return '2' # not sick = middle finger

# get whether a subject gets sick for given cueId and contextId
#
def get_is_sick(contextRole, cueId, contextId):
    assert cueId == 0 or cueId == 1 or cueId == 2
    assert contextId == 0 or contextId == 1 or contextId == 2

    if cueId == 2 or contextId == 2:
        return None # test trial

    if contextRole == 'irrelevant':
        if cueId == 0:
            return True
        else:
            return False

    elif contextRole == 'modulatory':
        if cueId == contextId:
            return True
        else:
            return False

    elif contextRole == 'additive':
        if contextId == 0:
            return True
        else:
            return False

    assert False, "Invalid context role: " + str(contextRole)

# random shuffle the conditions
# random, NOT full random => in batches
#
def gen_context_roles(nRuns):
    assert nRuns % 3 == 0
    contextRoles = []
    for _ in range(nRuns / 3):
        batch = roles[:]
        shuffle(batch)
        contextRoles.extend(batch)
    return contextRoles
        

# expand the ITI / stim sequence with stimOnset, stimOffset times, etc
#
def denormalize(jitter, stimTime, stim):
    stimOnset = []
    stimOffset = []
    cueId = []
    contextId = []
    t = 0
    for i in range(len(stimTime)):
        stimOnset.append(t)
        t += stimTime[i]
        stimOffset.append(t)
        t += jitter[i]

        stim_i = stim[i].lower()
        if 'x1' in stim_i:
            cueId.append(0)
        elif 'x2' in stim_i:
            cueId.append(1)
        else:
            assert 'x3' in stim_i
            cueId.append(2)

        if 'c1' in stim_i:
            contextId.append(0)
        elif 'c2' in stim_i:
            contextId.append(1)
        else:
            assert 'c3' in stim_i
            contextId.append(2)

    return stimOnset, stimOffset, cueId, contextId

# parse an ITI / stim sequence from a given csv file
#
def parse(fname):
    duration = []
    start = []
    stim = []
    with open(fname) as f:
        reader = csv.reader(f, delimiter=' ')
        for row in reader:
            row = filter(None, row)
            start.append(float(row[0]))
            duration.append(float(row[2]))
            stim.append(row[4])
    jitter = duration[1::2]
    stimTime = duration[0::2]
    start = start[0::2]
    stim = stim[0::2]
    assert len(stimTime) == len(stim)

    stimOnset, stimOffset, cueId, contextId = denormalize(jitter, stimTime, stim)
    assert stimOnset == start, " wtf " + str(stimOnset) + " vs " + str(start)

    #print stimOnset
    #print stimOffset
    #print jitter
    #print stimTime
    #print stim
    return stimOnset, stimOffset, jitter, stimTime, stim, cueId, contextId


# generate a test ITI / stim sequence for 1 run
#
def gen_test():
    stim = ['x1c1', 'x1c3', 'x3c1', 'x3c3']
    shuffle(stim)

    jitter = [2, 4, 6] # randomly shuffle ITI's of 2, 4, and 6 seconds, one of each
    shuffle(jitter)
    jitter.append(0) # no ITI after last test trial

    stimTime = [6] * 4 # each test trial is 6 seconds

    stimOnset, stimOffset, cueId, contextId = denormalize(jitter, stimTime, stim)

    print stimOnset
    print stimOffset
    print jitter
    print stimTime
    print stim
    return stimOnset, stimOffset, jitter, stimTime, stim, cueId, contextId

if __name__ == "__main__":
    isPractice = False 
    if len(sys.argv) >= 2:
        if sys.argv[1] in ['-p', '--practice']:
            isPractice = True

    pars = os.listdir("par")

    if isPractice:
        seed(545123) # different seed for practice
    else:
        seed(129523)

    train = []
    test = []

    for fname in pars:
        if fname.endswith('.par'):
            print fname
            x = parse(os.path.join("par", fname))
            train.append(x)

    assert len(train) % 9 == 0, "Should have multiple of 9 (# runs per subject) files; found " + str(len(train)) + " instead"
    n_subjects = len(train) / 9

    # these days we generate the test ITI / stim sequences manually
    #
    for _ in range(len(train)):
        x = gen_test()
        test.append(x)

    if isPractice:
        stimuli = practice_stimuli # use different stimuli for practice

    next_train_idx = 0
    next_test_idx = 0
    for subj in range(n_subjects):
        print '\n\n -------------------- Subject ', subj, ' -------------------\n'

        contextRoles = gen_context_roles(9)
        assert len(contextRoles) == 9

        cuisines = range(0, 9)
        shuffle(cuisines)
        
        train_jitters = []

        if isPractice:
            subjId = 'prac%03d' % subj # use a different subject id for practice
        else:
            subjId = 'con%03d' % subj
        subjFname = os.path.join('csv', '%s.csv' % subjId)
        with open(subjFname, 'w') as subjF:
            subjF.write('runFilename\n')

            for run in range(9):
                # write it out the itis and stim sequence for each subject for each run in a separate file
                # this is crucial for psychopy to work in fMRI mode -- it reads everything from here
                #
                contextRole = contextRoles[run]
                cuisine = cuisines[run]
                restaurants = stimuli[cuisine]['restaurants']
                shuffle(restaurants)
                foods = stimuli[cuisine]['foods']
                shuffle(foods)

                print '\n    Run ', run, ', contextRole ', contextRole
                fname = os.path.join('csv', '%s_run%d_itis.csv' % (subjId, run))
                subjF.write(os.path.join('itis', fname) + '\n')
                with open(fname, 'w') as f:
                    cols = ['subjectN', 'runN', 'trialN', 'contextRole',
                            'cueId', 'contextId', 'isSick', 'corrButton',
                            'isTest',
                            'choiceDuration', 'isiDuration', 'feedbackDuration', 'itiDuration',
                            'stimOnset', 'stimOffset', 'itiOffset',
                            'food', 'restaurant']
                    f.write(','.join(cols) + '\n')

                    # write training trials
                    #
                    t = 10 # starting point for first trial is after initial fixation TODO
                    stimOnset, stimOffset, jitter, stimTime, stim, cueId, contextId = train[next_train_idx]
                    assert sum(jitter) == 144 - 5 * 20, "Sum of train jitters is wrong: " + str(sum(jitter))
                    train_jitters.extend(jitter)
                    for i in range(20):
                        isSick = get_is_sick(contextRole, cueId[i], contextId[i])
                        corrButton = get_correct_button(isSick)
                        choiceDuration = 3
                        isTest = False
                        isiDuration = 1
                        feedbackDuration = 1
                        itiOffset = stimOffset[i] + jitter[i]
                        row = [subj, run, i, contextRole,
                               cueId[i], contextId[i], isSick, corrButton,
                               isTest,
                               choiceDuration, isiDuration, feedbackDuration, jitter[i],
                               stimOnset[i] + t, stimOffset[i] + t, itiOffset + t,
                               foods[cueId[i]], restaurants[contextId[i]]]
                        f.write(','.join(str(x) for x in row) + '\n')
                        print '                          ', cueId[i], contextId[i], 1 if isSick else 0, corrButton, jitter[i], itiOffset, '           ', foods[cueId[i]], restaurants[contextId[i]]
                    next_train_idx += 1
                   
                    # write test trials
                    #   
                    t += itiOffset # starting point for test trials = last offset
                    t += 4 # test warning

                    stimOnset, stimOffset, jitter, stimTime, stim, cueId, contextId = test[next_test_idx]
                    for i in range(4):
                        isSick = None
                        corrButton = None
                        isTest = True
                        choiceDuration = 6
                        isiDuration = 0 
                        feedbackDuration = 0 
                        itiOffset = stimOffset[i] + jitter[i]
                        row = [subj, run, i + 20, contextRole,
                               cueId[i], contextId[i], isSick, corrButton,
                               isTest,
                               choiceDuration, isiDuration, feedbackDuration, jitter[i],
                               stimOnset[i] + t, stimOffset[i] + t, itiOffset + t,
                               foods[cueId[i]], restaurants[contextId[i]]]
                        f.write(','.join(str(x) for x in row) + '\n')
                        print '                          ', cueId[i], contextId[i], 1 if isSick else 0, corrButton, jitter[i], itiOffset + t, '           ', foods[cueId[i]], restaurants[contextId[i]]
                    assert sum(jitter) == 36 - 6 * 4, "Sum of test jitters is wrong: " + str(sum(jitter))
                    next_test_idx += 1

                    assert t + itiOffset == 194, "It's " + str(t + itiOffset) 

                # only one run for practice
                #
                if isPractice:
                    break

    print 'mean = ', np.mean(train_jitters)
    print 'min = ', np.min(train_jitters)
    print 'max = ', np.max(train_jitters)
    print 'std = ', np.std(train_jitters)
